<!doctype html>
<html lang="en">

<head>
	<meta charset="utf-8">

	<title>reveal.js – The HTML Presentation Framework</title>

	<meta name="description" content="A framework for easily creating beautiful presentations using HTML">
	<meta name="author" content="Hakim El Hattab">

	<meta name="apple-mobile-web-app-capable" content="yes">
	<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

	<link rel="stylesheet" href="css/reveal.css">
	<link rel="stylesheet" href="css/theme/black.css" id="theme">

	<!-- Theme used for syntax highlighting of code -->
	<link rel="stylesheet" href="lib/css/zenburn.css">

	<!-- Printing and PDF exports -->
	<script>
		var link = document.createElement('link');
		link.rel = 'stylesheet';
		link.type = 'text/css';
		link.href = window.location.search.match(/print-pdf/gi) ? 'css/print/pdf.css' : 'css/print/paper.css';
		document.getElementsByTagName('head')[0].appendChild(link);
	</script>
	<script src="lib/js/jquery.js"></script>
	<script src="lib/js/poem.js"></script>
	<script src="lib/js/tables.js"></script>
	<script src="lib/js/external.js"></script>
	<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
</head>

<body>
	<script>
		const colors = ['#e6194b', '#3cb44b', '#9a6324', '#4363d8', '#f58231', '#911eb4', '#46f0f0', '#f032e6', '#bcf60c',
			'#fabebe', '#008080', '#e6beff', '#ffe119', '#fffac8', '#800000', '#aaffc3', '#808000', '#ffd8b1', '#000075'
		];

		function coursorToEnd(div) {

			div.focus();

			if (window.getSelection && document.createRange) {
				// IE 9 and non-IE
				var sel = window.getSelection();
				var range = document.createRange();
				range.setStart(div, div.childNodes.length);
				range.collapse(true);
				sel.removeAllRanges();
				sel.addRange(range);
			}
		}

		function stringNum2Bin(str) {
			if (!str.match(/^\d*$/)) {
				return ["Невозможно"];
			}
			var result = [];
			while (str.length >= 3) {
				let bin = parseInt(str.substr(0, 3)).toString(2);
				result.push("0".repeat(10 - bin.length) + bin);
				str = str.substr(3);
			}

			if (str.length == 2) {
				let bin = parseInt(str).toString(2);
				result.push("0".repeat(7 - bin.length) + bin);
			} else if (str.length == 1) {
				let bin = parseInt(str).toString(2);
				result.push("0".repeat(4 - bin.length) + bin);
			}

			return result;
		}



		function stringMix2Bin(str) {
			str = str.toUpperCase();
			for (let i = 0; i < str.length; i++) {
				if (possibleMixSymbols.indexOf(str[i]) == -1) {
					return ["Невозможно"];
				}
			}
			var result = [];
			while (str.length >= 2) {
				let bin = (mixConversionTable[str[0]] * 45 + mixConversionTable[str[1]]).toString(2);
				result.push("0".repeat(11 - bin.length) + bin);
				str = str.substr(2);
			}

			if (str.length == 1) {
				let bin = mixConversionTable[str[0]].toString(2);
				result.push("0".repeat(6 - bin.length) + bin);
			}

			return result;
		}

		function toUTF8Array(str) {
			var utf8 = [];
			for (var i = 0; i < str.length; i++) {
				var charcode = str.charCodeAt(i);
				if (charcode < 0x80) utf8.push(charcode);
				else if (charcode < 0x800) {
					utf8.push(0xc0 | (charcode >> 6),
						0x80 | (charcode & 0x3f));
				} else if (charcode < 0xd800 || charcode >= 0xe000) {
					utf8.push(0xe0 | (charcode >> 12),
						0x80 | ((charcode >> 6) & 0x3f),
						0x80 | (charcode & 0x3f));
				}
				// surrogate pair
				else {
					i++;
					// UTF-16 encodes 0x10000-0x10FFFF by
					// subtracting 0x10000 and splitting the
					// 20 bits of 0x0-0xFFFFF into two halves
					charcode = 0x10000 + (((charcode & 0x3ff) << 10) |
						(str.charCodeAt(i) & 0x3ff));
					utf8.push(0xf0 | (charcode >> 18),
						0x80 | ((charcode >> 12) & 0x3f),
						0x80 | ((charcode >> 6) & 0x3f),
						0x80 | (charcode & 0x3f));
				}
			}
			return utf8;
		}

		function string2Bin(str) {
			var result = [];
			for (var i = 0; i < str.length; i++) {
				let arr = toUTF8Array(str[i]);
				if (arr.length == 1) {
					let bin = toUTF8Array(str[i])[0].toString(2);
					result.push("0".repeat(8 - bin.length) + bin);
				} else {
					let bin1 = toUTF8Array(str[i])[0].toString(2);
					let bin2 = toUTF8Array(str[i])[1].toString(2);
					let bin = "0".repeat(8 - bin1.length) + bin1 + "0".repeat(8 - bin2.length) + bin2;
					result.push(bin);
				}

			}
			return result;
		}

		function getFieldsLen(type, ver) {
			if (type == 0) {
				if (ver <= 9) {
					return 10;
				} else if (ver <= 26) {
					return 12;
				} else {
					return 14;
				}
			} else if (type == 1) {
				if (ver <= 9) {
					return 9;
				} else if (ver <= 26) {
					return 11;
				} else {
					return 13;
				}
			} else if (type == 2) {
				if (ver <= 9) {
					return 8;
				} else if (ver <= 26) {
					return 16;
				} else {
					return 16;
				}
			}
		}

		function getFields(type, ver, bites) {
			var result = [];
			let len = getFieldsLen(type, ver)
			if (type == 0) {
				result.push("0001");
				let count = 0;
				for (let i = 0; i < bites.length; i++) {
					if (bites[i].length == 10) {
						count += 3;
					} else if (bites[i].length == 7) {
						count += 2;
					} else {
						count += 1;
					}
				}
				let bin = (count).toString(2);
				result.push("0".repeat(len - bin.length) + bin);
			} else if (type == 1) {
				result.push("0010");
				let count = 0;
				for (let i = 0; i < bites.length; i++) {
					if (bites[i].length == 11) {
						count += 2;
					} else {
						count += 1;
					}
				}
				let bin = count.toString(2);
				result.push("0".repeat(len - bin.length) + bin);
			} else if (type == 2) {
				result.push("0100");
				let bin = (bites.join('').length / 8).toString(2);
				result.push("0".repeat(len - bin.length) + bin);
			}
			//console.log(result);
			return result;
		}

		function calcVersion(bits, type, cor) {
			let targetLen = bits.join('').length;
			for (let i = 1; i <= 40; i++) {
				if (getNumDataCodewords(i, cor) * 8 >= targetLen + getFieldsLen(type, i) + 4) {
					return i;
				}
			}
		}

		function fillData(bits, ver, cor) {
			let targetLen = getNumDataCodewords(ver, cor) * 8;
			let result = bits.join('');
			result += "0".repeat(Math.min(4, targetLen - result.length));

			result += "0".repeat((8 - result.length % 8) % 8);
			//console.log(targetLen);

			let i = 0;
			while (result.length < targetLen) {
				result += (i % 2 == 0) ? "11101100" : "00010001";
				i++;
			}

			return result;
		}

		function blockify(bits, ver, cor) {
			let bytes = [];
			for (let i = 0; i < bits.length; i += 8) {
				bytes.push(bits.substr(i, 8));
			}
			let blocksCount = NUM_ERROR_CORRECTION_BLOCKS[cor][ver];
			let bytesPerBlock = parseInt(bytes.length / blocksCount);
			let extendedBlockCount = bytes.length % blocksCount;

			let result = [];
			for (let i = 0; i < blocksCount; i++) {
				result.push([]);
				for (let j = 0; j < bytesPerBlock + (blocksCount - i <= extendedBlockCount ? 1 : 0); j++) {
					result[i].push(bytes.shift());
				}
			}
			return result;
		}

		function getCorrData(blocks, ver, cor) {
			let result = [];
			//console.log(cor, ver);
			let rs = new ReedSolomonGenerator(ECC_CODEWORDS_PER_BLOCK[cor][ver]);

			for (var i = 0, k = 0; i < blocks.length; i++) {
				var dat = blocks[i].map(x => parseInt(x, 2));
				//console.log(dat);
				k += dat.length;
				var ecc = rs.getRemainder(dat);
				result[i] = [];
				for (let j = 0; j < ecc.length; j++) {
					let bin = ecc[j].toString(2);
					result[i].push("0".repeat(8 - bin.length) + bin);
				}
			}
			//console.log(result);
			return result;
		}

		let field = {};

		function drawCode(blocks, corrBlocks, ver, cor, mask, scale, canvas) {
			let $c = $(canvas);
			let size = (ver * 4 + 17);
			$c.attr("width", (size + 8) * scale);
			$c.attr("height", (size + 8) * scale);
			const ctx = canvas.getContext("2d");
			ctx.fillStyle = '#fff';
			ctx.fillRect(0, 0, (size + 8) * scale, (size + 8) * scale);
			let field = [];
			let uField = [];
			for (let i = 0; i < size; i++) {
				field.push([]);
				for (let j = 0; j < size; j++) {
					field[i].push(false);
				}
			}

			uField = field.map(x => x.slice(0));
			drawTimingPatterns(field, uField, ver);
			drawPosPatterns(field, uField, ver);
			drawAlignmentPatterns(field, uField, ver);
			drawVersion(field, uField, ver);
			drawFormatBits(field, uField, mask, cor);
			//console.log(blocks);
			let dataBits = joinBlocks(blocks, corrBlocks);
			drawDataBits(field, uField, dataBits);


			if (true) {
				applyMask(field, uField, masks[mask])
			}
			drawField(field, scale, ctx);
		}

		function drawFinderPattern(field, uField, x, y) {
			const size = field.length;
			for (var dy = -4; dy <= 4; dy++) {
				for (var dx = -4; dx <= 4; dx++) {
					var dist = Math.max(Math.abs(dx), Math.abs(dy)); // Chebyshev/infinity norm
					var xx = x + dx,
						yy = y + dy;
					if (0 <= xx && xx < size && 0 <= yy && yy < size) {
						uField[xx][yy] = 1;
						if (dist != 2 && dist != 4) {
							field[xx][yy] = true;
						} else {
							field[xx][yy] = false;
						}
					}
				}
			}
		}

		function drawAlignmentPattern(field, uField, x, y) {
			for (var dy = -2; dy <= 2; dy++) {
				for (var dx = -2; dx <= 2; dx++) {
					var dist = Math.max(Math.abs(dx), Math.abs(dy)); // Chebyshev/infinity norm
					uField[x + dx][y + dy] = 2;
					if (dist != 1) {
						field[x + dx][y + dy] = true;
					} else {
						field[x + dx][y + dy] = false;
					}
				}
			}
		}

		function drawPosPatterns(field, uField, ver) {
			const size = field.length;
			drawFinderPattern(field, uField, 3, 3);
			drawFinderPattern(field, uField, size - 4, 3);
			drawFinderPattern(field, uField, 3, size - 4);
		}

		function drawAlignmentPatterns(field, uField, ver) {
			const size = field.length;
			var alignPatPos = getAlignmentPatternPositions(ver, size);
			var numAlign = alignPatPos.length;
			for (var i = 0; i < numAlign; i++) {
				for (var j = 0; j < numAlign; j++) {
					// Don't draw on the three finder corners
					if (!(i == 0 && j == 0 || i == 0 && j == numAlign - 1 || i == numAlign - 1 && j == 0))
						drawAlignmentPattern(field, uField, alignPatPos[i], alignPatPos[j]);
				}
			}
		}

		function drawVersion(field, uField, version) {
			if (version < 7)
				return;
			const size = field.length;
			// Calculate error correction code and pack bits
			var rem = version; // version is uint6, in the range [7, 40]
			for (var i = 0; i < 12; i++)
				rem = (rem << 1) ^ ((rem >>> 11) * 0x1F25);
			var bits = version << 12 | rem; // uint18
			if (bits >>> 18 != 0)
				throw "Assertion error";

			// Draw two copies
			for (var i = 0; i < 18; i++) {
				var bit = getBit(bits, i);
				var a = size - 11 + i % 3;
				var b = Math.floor(i / 3);
				uField[a][b] = uField[b][a] = 4;
				field[a][b] = field[b][a] = bit;
			}
		}


		function drawTimingPatterns(field, uField, ver) {
			const size = field.length;
			for (var i = 0; i < size; i++) {
				uField[6][i] = 3;
				uField[i][6] = 3;
				if (i % 2 == 0) {
					field[6][i] = true;
					field[i][6] = true;
				} else {
					field[6][i] = false;
					field[i][6] = false;
				}
			}
		}

		function drawFormatBits(field, uField, mask, cor) {
			const size = field.length;
			// Calculate error correction code and pack bits
			var data = [1, 0, 3, 2][cor] << 3 | mask; // errCorrLvl is uint2, mask is uint3
			var rem = data;
			for (var i = 0; i < 10; i++)
				rem = (rem << 1) ^ ((rem >>> 9) * 0x537);
			var bits = (data << 10 | rem) ^ 0x5412; // uint15
			if (bits >>> 15 != 0)
				throw "Assertion error";

			// Draw first copy
			for (var i = 0; i <= 5; i++) {
				field[8][i] = getBit(bits, i);
				uField[8][i] = 5;
			}

			uField[8][7] = uField[8][8] = uField[7][8] = 5;
			field[8][7] = getBit(bits, 6);
			field[8][8] = getBit(bits, 7);
			field[7][8] = getBit(bits, 8);

			for (var i = 9; i < 15; i++) {
				uField[14 - i][8] = 5;
				field[14 - i][8] = getBit(bits, i);
			}

			// Draw second copy
			for (var i = 0; i < 8; i++) {
				uField[size - 1 - i][8] = 5;
				field[size - 1 - i][8] = getBit(bits, i);
			}
			for (var i = 8; i < 15; i++) {
				uField[8][size - 15 + i] = 5;
				field[8][size - 15 + i] = getBit(bits, i);
			}
			uField[8][size - 8] = 5;
			field[8][size - 8] = true;
		}

		function joinBlocks(blocks, corBlocks) {
			let result = [];
			for (let j = 0; j < blocks[blocks.length - 1].length; j++) {
				for (let i = 0; i < blocks.length; i++) {
					if (blocks[i][j]) {
						for (let k = 0; k < 8; k++) {
							result.push(blocks[i][j][k] == '1' ? true : false);
						}
					}
				}
			}

			for (let j = 0; j < corBlocks[corBlocks.length - 1].length; j++) {
				for (let i = 0; i < corBlocks.length; i++) {
					if (corBlocks[i][j]) {
						for (let k = 0; k < 8; k++) {
							result.push(corBlocks[i][j][k] == '1' ? true : false);
						}
					}
				}
			}

			return result;
		}

		function drawDataBits(field, uField, bits) {
			const size = field.length;

			let str = "";
			for (let i = 0; i < bits.length; i += 8) {
				str += bits.slice(i, i + 8).map(x => x ? '1' : '0').join('') + "\n";
			}
			//console.log(str);

			let c = 0;
			for (let i = 0; i < size / 2; i++) {
				let x = size - i * 2 - 1;
				if (x <= 6) {
					x--;
				}
				for (let j = 0; j < size; j++) {
					let y = ((i % 2 != 0) ? j : size - j - 1);
					for (let k = 0; k < 2 && x - k >= 0; k++) {
						if (!uField[x - k][y]) {
							if (c < bits.length) {
								field[x - k][y] = bits[c];
							}
							uField[x - k][y] = 6;
							c++;
						}
					}
				}
			}
		}

		function applyMask(field, uField, mask) {
			const size = field.length;
			for (let i = 0; i < size; i++) {
				for (let j = 0; j < size; j++) {
					if (uField[i][j] == 6 && !mask(i, j)) {
						field[i][j] = !field[i][j];
					}
				}
			}
		}


		function drawField(field, scale, ctx) {
			ctx.fillStyle = '#000';
			for (let i = 4; i < field.length + 4; i++) {
				for (let j = 4; j < field.length + 4; j++) {
					if (field[i - 4][j - 4]) {
						ctx.fillRect(i * scale, j * scale, scale, scale);
					}
				}
			}
		}

		function getBestType(text) {
			let num = stringNum2Bin(text);
			let mix = stringMix2Bin(text);
			let bin = string2Bin(text);
			if (text == "" || num[0][0] != "Н") {
				return 0;
			} else if (mix[0][0] != "Н") {
				return 1;
			} else {
				return 2;
			}
		}
	</script>
	<div class="reveal">

		<!-- Any section element inside of this container is displayed as a slide -->
		<div class="slides">
			<section>
				<h1>Демо</h1>
				<div id="0-0-input" class='edit' contenteditable="true"
					style="background-color: white; color: black; margin-bottom: 5px; font-size: 5px">
				</div>
				<canvas id="demo-code"></canvas>
				<script>
					$('#0-0-input').keyup((e) => {
						const me = $(e.target);
						const text = me.text();
						let bin = stringNum2Bin(text);
						var cor = 0;
						var type = 0;
						var ver = calcVersion(bin, type, cor);
						bin = getFields(type, ver, bin).concat(bin);
						let filled = fillData(bin, ver, cor);
						let blocks = blockify(filled, ver, cor);
						let corrBlocks = getCorrData(blocks, ver, cor);
						drawCode(blocks, corrBlocks, ver, cor, 0, 5, document.getElementById('demo-code'))
					});
				</script>
			</section>
			<section>
				<h1>Генерация QR кодов</h1>
				<canvas id="0-0-qr"></canvas>
				<script>
					let bin = string2Bin("Продам гараж");
					var cor = 0;
					var type = 2;
					var ver = calcVersion(bin, type, cor);
					bin = getFields(type, ver, bin).concat(bin);
					let filled = fillData(bin, ver, cor);
					let blocks = blockify(filled, ver, cor);
					let corrBlocks = getCorrData(blocks, ver, cor);
					drawCode(blocks, corrBlocks, ver, cor, 0, 10, document.getElementById('0-0-qr'))
				</script>
			</section>
			<section>
				<h2>Этапы генерации QR кода</h1>
					<ol>
						<li>Кодирование данных</li>
						<li>Добавление служебной информации и заполнения</li>
						<li>Разделение информации на блоки</li>
						<li>Создание байтов коррекции</li>
						<li>Объединение блоков</li>
						<li>Размещение информации на QR коде</li>
					</ol>
			</section>
			<section>
				<section>
					<h1>
						Кодирование данных
					</h1>
				</section>
				<section>
					<h3>
						Виды кодирования
					</h3>
				</section>
				<section>
					<h4>Цифровое кодирование</h4>
					<p style='font-size: 30px'>
						Алгоритм: Этот тип кодирования требует 10 бит на 3 символа. Вся последовательность символов
						разбивается на
						группы по 3 цифры, и каждая группа (трёхзначное число) переводится в 10-битное двоичное число и
						добавляется
						к последовательности бит. Если общее количество символов не кратно 3, то если в конце остаётся 2
						символа,
						полученное двузначное число кодируется 7 битами, а если 1 символ, то 4 битами.
					</p>
					<div id="2-2-input" class='edit' contenteditable="true"
						style="background-color: white; margin-bottom: 5px">
					</div>
					<div id="2-2-output" class='edit'
						style="background-color: grey; height: 160px; overflow-wrap: break-word;">
					</div>
					<script>
						$('#2-2-input').keyup((e) => {
							const me = $(e.target);
							const text = me.text();
							me.html('');
							for (let i = 0; i < text.length; i += 3) {
								me.append($(
									`<span style='color:${colors[i / 3 % colors.length]}'>${text.substr(i, 3)}</span>`
								));
							}
							coursorToEnd(e.target);

							const output = $("#2-2-output");
							let bin = stringNum2Bin(text);
							output.html('');
							for (let i = 0; i < bin.length; i++) {
								output.append($(
									`<span style='color:${colors[i % colors.length]}'>${bin[i]}</span>`
								));
							}
						});
					</script>
				</section>
				<section>
					<h4>Буквенно-цифровое кодирование</h4>
					<p style='font-size: 20px'>
						В этом случае на 2 символа требуется 11 бит информации. Входной поток символов разделяется на
						группы по 2, в
						группе каждый символ кодируется согласно таблице внизу, значение первого символа в группе
						умножается на 45 и
						прибавляется к значение второго символа. Полученное число переводится в 11-битное двоичное число
						и
						добавляется к последовательности бит. Если в последней группе 1 символ, то его значение сразу
						кодируется
						6-битным числом и добавляется к последовательности бит.
					</p>
					<img src='lib/images/symb_talbe.png' style='background: none; border: none; margin: 0'>
					<div id="2-3-input" class='edit' contenteditable="true"
						style="background-color: white; margin-bottom: 5px">
					</div>
					<div id="2-3-output" class='edit'
						style="background-color: grey; height: 130px; overflow-wrap: break-word;">
					</div>
					<script>
						$('#2-3-input').keyup((e) => {
							const me = $(e.target);
							const text = me.text();
							me.html('');
							for (let i = 0; i < text.length; i += 2) {
								me.append($(
									`<span style='color:${colors[i / 2 % colors.length]}'>${text.substr(i, 2)}</span>`
								));
							}
							coursorToEnd(e.target);

							const output = $("#2-3-output");
							let bin = stringMix2Bin(text);
							output.html('');
							for (let i = 0; i < bin.length; i++) {
								output.append($(
									`<span style='color:${colors[i % colors.length]}'>${bin[i]}</span>`
								));
							}
						});
					</script>
				</section>
				<section>
					<h4>Побайтовое кодирование</h4>
					<p style='font-size: 30px'>
						Это универсальный способ кодирования, которым можно закодировать любые символы. Единственным
						недостатком
						метода является относительно низкая плотность информации. В этом случае текст кодируется в любой
						кодировке
						(Я буду использвать UTF-8, это значит что каждый символ будет занимать 8 или 16 бит) и
						полученная
						последовательность байт берётся в неизменном виде.
					</p>
					<div id="2-4-input" class='edit' contenteditable="true"
						style="background-color: white; margin-bottom: 5px">
					</div>
					<div id="2-4-output" class='edit'
						style="background-color: grey; height: 210px; overflow-wrap: break-word;">
					</div>
					<script>
						$('#2-4-input').keyup((e) => {
							const me = $(e.target);
							const text = me.text();
							me.html('');
							for (let i = 0; i < text.length; i += 1) {
								me.append($(
									`<span style='color:${colors[i / 1 % colors.length]}'>${text.substr(i, 1)}</span>`
								));
							}
							coursorToEnd(e.target);

							const output = $("#2-4-output");
							let bin = string2Bin(text);
							output.html('');
							for (let i = 0; i < bin.length; i++) {
								output.append($(
									`<span style='color:${colors[i % colors.length]}'>${bin[i]}</span>`
								));
							}
						});
					</script>
				</section>
				<section>
					<textarea type="text" style="width: 100%;height: 100px;" id="2-5-input"></textarea>
					<label>Цифровое кодирование</label>
					<textarea id="2-4-output-1" style="width: 100%;height: 100px; font-size:20px" disabled></textarea>
					<label>Буквенно-цифровое кодирование</label>
					<textarea id="2-4-output-2" style="width: 100%;height: 100px; font-size:20px" disabled></textarea>
					<label>Побайтовое кодирование</label>
					<textarea id="2-4-output-3" style="width: 100%;height: 100px; font-size:20px" disabled></textarea>
					<script>
						$('#2-5-input').keyup((e) => {
							let value = e.target.value;
							let binNum = stringNum2Bin(value);
							let binMix = stringMix2Bin(value);
							let bin = string2Bin(value);
							$('#2-4-output-1').val(binNum.join(''));
							$('#2-4-output-2').val(binMix.join(''));
							$('#2-4-output-3').val(bin.join(''));
						});
					</script>
				</section>
			</section>
			<section>
				<section>
					<h1>
						Добавление служебной информации и заполнения
					</h1>
				</section>
				<section>
					<h2>
						Выбор уровня коррекции и версии
					</h2>
				</section>
				<section>
					<h3>
						Уровни кореекции
					</h3>
					<ul>
						<li>
							L - 7%
						</li>
						<li>
							M - 15%
						</li>
						<li>
							Q - 25%
						</li>
						<li>
							H - 30%
						</li>
					</ul>
					<br>
					<br>
				</section>
				<section>
					<h3>
						Версия
					</h3>
					</h4>От 1 до 40</h4>
				</section>
				<section>
					<div>
						<input type="number" id="6-4-input" min="1" max="40"
							style="height: 20px; margin: 5px auto; display: block" value='1'>
					</div>
					<div style="display: flex; justify-content: center; width: 100%">
						<canvas id="6-4-qr-1"></canvas>
						<code id="6-4-output" class="hljs" style="font-size: 12px; width: inherit"></code>
					</div>
					<script>
						function upd64(ver) {
							let bitsPosible = getNumDataCodewords(ver, 2) * 8 - 4 - getFieldsLen(2, ver);
							let poemPart = poem.substr(0, parseInt(bitsPosible / 8));
							$("#6-4-output").text(poemPart);
							bin = string2Bin(poemPart);
							var cor = 0;
							var type = 2;
							bin = getFields(2, ver, bin).concat(bin);
							filled = fillData(bin, ver, cor);
							blocks = blockify(filled, ver, cor);
							corrBlocks = getCorrData(blocks, ver, cor);
							drawCode(blocks, corrBlocks, ver, cor, 0, 2, document.getElementById('6-4-qr-1'))
						}
						$("#6-4-input").change(function (e) {
							let ver = $(e.target).val();
							upd64(ver);
						});
						upd64(1);
					</script>
				</section>
				<section>
					<div id="f6-6-table-div">
						<table id="f6-6-table">
							<thead>
								<tr>
									<th>Версия</th>
									<th>Моудлей</th>
									<th>Уровень коррекции</th>
									<th>Бит данных</th>
									<th>Цифровое</th>
									<th>Буквенно-цифровое</th>
									<th>Побайтовое</th>
								</tr>
							</thead>
							<tbody>

							</tbody>
						</table>
					</div>
					<style>
						#f6-6-table {
							font-size: 15px;
						}

						#f6-6-table-div {
							height: 70vh;
							overflow-y: scroll;
						}

						#f6-6-table td {
							text-align: center;
							vertical-align: middle;
						}

						#f6-6-table tr:nth-child(2n) {
							background-color: rgba(255, 255, 255, 0.3);
						}
					</style>
					<script>
						for (let i = 1; i <= 40; i++) {
							let row = $('<tr></tr>');
							row.append($(`<td rowspan=4>${i}</td>`));
							row.append($(`<td rowspan=4>${i * 4 + 17}</td>`));

							for (let j = 0; j < 4; j++) {
								if (j != 0) {
									row = $('<tr></tr>');
								}
								row.append($(`<td>${corrLetters[j]}</td>`));
								let bits = getNumDataCodewords(i, j) * 8;
								row.append($(`<td>${bits}</td>`));
								bits -= 4;
								const num = bits - getFieldsLen(0, i),
									mixed = bits - getFieldsLen(1, i),
									bin = bits - getFieldsLen(2, i);
								const numRem = num % 10,
									mixedRem = mixed % 11;
								row.append($(`<td>${parseInt(num / 10) * 3 + (numRem ? (numRem >= 7 ? 2 : 1) : 0)}</td>`));
								row.append($(`<td>${parseInt(mixed / 11) * 2 + (mixedRem ? 1 : 0)}</td>`));
								row.append($(`<td>${parseInt(bin / 8)}</td>`));
								$('#f6-6-table>tbody').append(row);
							}
						}
					</script>
				</section>
				<section>
					<input type="text" id="6-7-input-1" style="width: 100%">
					<br>
					<span id="6-7-output-1">Длинна: 0</span>
					<br>
					<span id="6-7-output-2">Тип: Цифровое</span>
					<br>
					<button class="f6-7-input-2" level="0" disabled>L</button>
					<button class="f6-7-input-2" level="1">M</button>
					<button class="f6-7-input-2" level="2">Q</button>
					<button class="f6-7-input-2" level="3">H</button>


					<br>
					<span id="6-7-output-3">Версия: 1</span>
					<script>
						$('#6-7-input-1').keyup((e) => {
							upd67();
						});

						$('.f6-7-input-2').click(function () {
							$(".f6-7-input-2").removeAttr('disabled');
							$(this).attr('disabled', 'true');
							upd67();
						});

						function upd67() {
							const text = $("#6-7-input-1").val();

							let num = stringNum2Bin(text);
							let mix = stringMix2Bin(text);
							let bin = string2Bin(text);

							let type = getBestType(text),
								len,
								cor = $('.f6-7-input-2[disabled]').attr('level');

							if (type <= 1) {
								len = text.length;
							} else {
								let bin = string2Bin(text);
								len = bin.join('').length / 8;
							}

							$("#6-7-output-1").text(`Длинна: ${len}`);
							$("#6-7-output-2").text(`Тип: ${["Цифровое", "Буквенно-цифровое", "Побайтовое"][type]}`);
							$("#6-7-output-3").text(`Версия: ${calcVersion([num, mix, bin][type], type, cor)}`);
						}
					</script>
					<style>
						.f6-7-input-2 {
							height: 50px;
							width: 50px;
						}
					</style>
				</section>
				<section>
					<h2>
						Добавление служебных полей
					</h2>
				</section>
				<section>
					<table style="font-size: 23px">
						<thead>
							<th>Способ кодирования</th>
							<th>Код способа</th>
							<th>Версия 1–9</th>
							<th>Версия 10–26</th>
							<th>Версия 27–40</th>
						</thead>
						<tbody>
							<tr>
								<td>Цифровое</td>
								<td>0001</td>
								<td>10 бит</td>
								<td>12 бит</td>
								<td>14 бит</td>
							</tr>
							<tr>
								<td>Буквенно-цифровое</td>
								<td>0010</td>
								<td>9 бит</td>
								<td>11 бит</td>
								<td>13 бит</td>
							</tr>
							<tr>
								<td>Побайтовое</td>
								<td>0100</td>
								<td>8 бит</td>
								<td>16 бит</td>
								<td>16 бит</td>
							</tr>
						</tbody>
					</table>

				</section>
				<section>
					<input type="text" id="6-9-input-1" style="width: 100%">
					<br>
					<span id="6-9-output-1">Длинна: 0</span>
					<br>
					<span id="6-9-output-2">Тип: Цифровое</span>
					<br>
					<button class="f6-9-input-2" level="0" disabled>L</button>
					<button class="f6-9-input-2" level="1">M</button>
					<button class="f6-9-input-2" level="2">Q</button>
					<button class="f6-9-input-2" level="3">H</button>
					<br>
					<span id="6-9-output-3">Версия: 1</span>
					<div id="6-9-output-4" class='edit'
						style="background-color: grey; height: 50px; overflow-wrap: break-word; margin-bottom: 20px">
					</div>
					<script>
						$('#6-9-input-1').keyup((e) => {
							upd69();
						});

						$('.f6-9-input-2').click(function () {
							$(".f6-9-input-2").removeAttr('disabled');
							$(this).attr('disabled', 'true');
							upd69();
						});

						function upd69() {
							const text = $("#6-9-input-1").val();

							let num = stringNum2Bin(text);
							let mix = stringMix2Bin(text);
							let bin = string2Bin(text);

							let type = getBestType(text),
								len,
								cor = $('.f6-9-input-2[disabled]').attr('level');

							if (type <= 1) {
								len = text.length;
							} else {
								let bin = string2Bin(text);
								len = bin.join('').length / 8;
							}
							bin = [num, mix, bin][type];
							let ver = calcVersion(bin, type, cor);
							$("#6-9-output-1").text(`Длинна: ${len}`);
							$("#6-9-output-2").text(`Тип: ${["Цифровое", "Буквенно-цифровое", "Побайтовое"][type]}`);
							$("#6-9-output-3").text(`Версия: ${ver}`);
							let fields = getFields(type, ver, bin);
							$('#6-9-output-4').html('');
							for (let i = 0; i < fields.length; i++) {
								$('#6-9-output-4').append($(
									`<span style='color:${colors[i % colors.length]}'>${fields[i]}</span>`
								));
							}
						}
					</script>
					<style>
						.f6-9-input-2 {
							height: 50px;
							width: 50px;
						}
					</style>
				</section>
				<section>
					<h2>
						Заполнение
					</h2>
				</section>
				<section>
					<h2>
						<p style='font-size: 30px'>
							Алгоритм: Сначала мы добавляем в конец последовательности 4 нуля(или столько, сколько
							возможно без увеличения версии), затем мы добавляем столько нулей, сколько необходимо,
							чтобы длинна последовательности стала кратна 8. И наконец если у нас получилось меньше бит
							чем нужно в текущей версии, мы дополняем последовательность чередующимися байтами 11101100 и
							00010001
						</p>
					</h2>
				</section>
				<section>
					<section>
						<input type="text" id="6-11-input-1" style="width: 100%">
						<br>
						<span id="6-11-output-1">Длинна: 0</span>
						<br>
						<span id="6-11-output-2">Тип: Цифровое</span>
						<br>
						<button class="f6-11-input-2" level="0" disabled>L</button>
						<button class="f6-11-input-2" level="1">M</button>
						<button class="f6-11-input-2" level="2">Q</button>
						<button class="f6-11-input-2" level="3">H</button>
						<br>
						<span id="6-11-output-3">Версия: 1</span>
						<div id="6-11-output-4" class='edit'
							style="background-color: grey; height: 50px; overflow-wrap: break-word; margin-bottom: 20px">
						</div>
						<script>
							$('#6-11-input-1').keyup((e) => {
								upd611();
							});

							$('.f6-11-input-2').click(function () {
								$(".f6-11-input-2").removeAttr('disabled');
								$(this).attr('disabled', 'true');
								upd611();
							});

							function upd611() {
								const text = $("#6-11-input-1").val();

								let num = stringNum2Bin(text);
								let mix = stringMix2Bin(text);
								let bin = string2Bin(text);

								let type = getBestType(text),
									len,
									cor = $('.f6-11-input-2[disabled]').attr('level');

								if (type <= 1) {
									len = text.length;
								} else {
									let bin = string2Bin(text);
									len = bin.join('').length / 8;
								}
								bin = [num, mix, bin][type];
								let ver = calcVersion(bin, type, cor);
								$("#6-11-output-1").text(`Длинна: ${len}`);
								$("#6-11-output-2").text(`Тип: ${["Цифровое", "Буквенно-цифровое", "Побайтовое"][type]}`);
								$("#6-11-output-3").text(`Версия: ${ver}`);
								let fields = getFields(type, ver, bin);
								$('#6-11-output-4').html('');
								for (let i = 0; i < fields.length; i++) {
									$('#6-11-output-4').append($(
										`<span style='color:${colors[i % colors.length]}'>${fields[i]}</span>`
									));
								}
							}
						</script>
						<style>
							.f6-11-input-2 {
								height: 50px;
								width: 50px;
							}
						</style>
					</section>
				</section>
			</section>

			<section>
				<h2>Hello There</h2>
				<p>
					reveal.js enables you to create beautiful interactive slide decks using HTML. This presentation will
					show you examples of what it can do.
				</p>
			</section>

			<!-- Example of nested vertical slides -->
			<section>
				<section>
					<h2>Vertical Slides</h2>
					<p>Slides can be nested inside of each other.</p>
					<p>Use the <em>Space</em> key to navigate through all slides.</p>
					<br>
					<a href="#" class="navigate-down">
						<img width="178" height="238"
							data-src="https://s3.amazonaws.com/hakim-static/reveal-js/arrow.png" alt="Down arrow">
					</a>
				</section>
				<section>
					<h2>Basement Level 1</h2>
					<p>Nested slides are useful for adding additional detail underneath a high level horizontal slide.
					</p>
				</section>
				<section>
					<h2>Basement Level 2</h2>
					<p>That's it, time to go back up.</p>
					<br>
					<a href="#/2">
						<img width="178" height="238"
							data-src="https://s3.amazonaws.com/hakim-static/reveal-js/arrow.png" alt="Up arrow"
							style="transform: rotate(180deg); -webkit-transform: rotate(180deg);">
					</a>
				</section>
			</section>

			<section>
				<h2>Slides</h2>
				<p>
					Not a coder? Not a problem. There's a fully-featured visual editor for authoring these, try it out
					at <a href="https://slides.com" target="_blank">https://slides.com</a>.
				</p>
			</section>

			<section>
				<h2>Point of View</h2>
				<p>
					Press <strong>ESC</strong> to enter the slide overview.
				</p>
				<p>
					Hold down alt and click on any element to zoom in on it using <a
						href="http://lab.hakim.se/zoom-js">zoom.js</a>. Alt + click anywhere to zoom back out.
				</p>
			</section>

			<section>
				<h2>Touch Optimized</h2>
				<p>
					Presentations look great on touch devices, like mobile phones and tablets. Simply swipe through your
					slides.
				</p>
			</section>

			<section data-markdown>
				<script type="text/template">
					## Markdown support

						Write content using inline or external Markdown.
						Instructions and more info available in the [readme](https://github.com/hakimel/reveal.js#markdown).

						```
						<section data-markdown>
						  ## Markdown support

						  Write content using inline or external Markdown.
						  Instructions and more info available in the [readme](https://github.com/hakimel/reveal.js#markdown).
						</section>
						```
					</script>
			</section>

			<section>
				<section id="fragments">
					<h2>Fragments</h2>
					<p>Hit the next arrow...</p>
					<p class="fragment">... to step through ...</p>
					<p><span class="fragment">... a</span> <span class="fragment">fragmented</span> <span
							class="fragment">slide.</span></p>

					<aside class="notes">
						This slide has fragments which are also stepped through in the notes window.
					</aside>
				</section>
				<section>
					<h2>Fragment Styles</h2>
					<p>There's different types of fragments, like:</p>
					<p class="fragment grow">grow</p>
					<p class="fragment shrink">shrink</p>
					<p class="fragment fade-out">fade-out</p>
					<p>
						<span style="display: inline-block;" class="fragment fade-right">fade-right, </span>
						<span style="display: inline-block;" class="fragment fade-up">up, </span>
						<span style="display: inline-block;" class="fragment fade-down">down, </span>
						<span style="display: inline-block;" class="fragment fade-left">left</span>
					</p>
					<p class="fragment fade-in-then-out">fade-in-then-out</p>
					<p class="fragment fade-in-then-semi-out">fade-in-then-semi-out</p>
					<p>Highlight <span class="fragment highlight-red">red</span> <span
							class="fragment highlight-blue">blue</span>
						<span class="fragment highlight-green">green</span></p>
				</section>
			</section>

			<section id="transitions">
				<h2>Transition Styles</h2>
				<p>
					You can select from different transitions, like: <br>
					<a href="?transition=none#/transitions">None</a> -
					<a href="?transition=fade#/transitions">Fade</a> -
					<a href="?transition=slide#/transitions">Slide</a> -
					<a href="?transition=convex#/transitions">Convex</a> -
					<a href="?transition=concave#/transitions">Concave</a> -
					<a href="?transition=zoom#/transitions">Zoom</a>
				</p>
			</section>

			<section id="themes">
				<h2>Themes</h2>
				<p>
					reveal.js comes with a few themes built in: <br>
					<!-- Hacks to swap themes after the page has loaded. Not flexible and only intended for the reveal.js demo deck. -->
					<a href="#"
						onclick="document.getElementById('theme').setAttribute('href','css/theme/black.css'); return false;">Black
						(default)</a> -
					<a href="#"
						onclick="document.getElementById('theme').setAttribute('href','css/theme/white.css'); return false;">White</a>
					-
					<a href="#"
						onclick="document.getElementById('theme').setAttribute('href','css/theme/league.css'); return false;">League</a>
					-
					<a href="#"
						onclick="document.getElementById('theme').setAttribute('href','css/theme/sky.css'); return false;">Sky</a>
					-
					<a href="#"
						onclick="document.getElementById('theme').setAttribute('href','css/theme/beige.css'); return false;">Beige</a>
					-
					<a href="#"
						onclick="document.getElementById('theme').setAttribute('href','css/theme/simple.css'); return false;">Simple</a>
					<br>
					<a href="#"
						onclick="document.getElementById('theme').setAttribute('href','css/theme/serif.css'); return false;">Serif</a>
					-
					<a href="#"
						onclick="document.getElementById('theme').setAttribute('href','css/theme/blood.css'); return false;">Blood</a>
					-
					<a href="#"
						onclick="document.getElementById('theme').setAttribute('href','css/theme/night.css'); return false;">Night</a>
					-
					<a href="#"
						onclick="document.getElementById('theme').setAttribute('href','css/theme/moon.css'); return false;">Moon</a>
					-
					<a href="#"
						onclick="document.getElementById('theme').setAttribute('href','css/theme/solarized.css'); return false;">Solarized</a>
				</p>
			</section>

			<section>
				<section data-background="#dddddd">
					<h2>Slide Backgrounds</h2>
					<p>
						Set <code>data-background="#dddddd"</code> on a slide to change the background color. All CSS
						color formats are supported.
					</p>
					<a href="#" class="navigate-down">
						<img width="178" height="238"
							data-src="https://s3.amazonaws.com/hakim-static/reveal-js/arrow.png" alt="Down arrow">
					</a>
				</section>
				<section data-background="https://s3.amazonaws.com/hakim-static/reveal-js/image-placeholder.png">
					<h2>Image Backgrounds</h2>
					<pre><code class="hljs">&lt;section data-background="image.png"&gt;</code></pre>
				</section>
				<section data-background="https://s3.amazonaws.com/hakim-static/reveal-js/image-placeholder.png"
					data-background-repeat="repeat" data-background-size="100px">
					<h2>Tiled Backgrounds</h2>
					<pre><code class="hljs" style="word-wrap: break-word;">&lt;section data-background="image.png" data-background-repeat="repeat" data-background-size="100px"&gt;</code></pre>
				</section>
				<section
					data-background-video="https://s3.amazonaws.com/static.slid.es/site/homepage/v1/homepage-video-editor.mp4,https://s3.amazonaws.com/static.slid.es/site/homepage/v1/homepage-video-editor.webm"
					data-background-color="#000000">
					<div style="background-color: rgba(0, 0, 0, 0.9); color: #fff; padding: 20px;">
						<h2>Video Backgrounds</h2>
						<pre><code class="hljs" style="word-wrap: break-word;">&lt;section data-background-video="video.mp4,video.webm"&gt;</code></pre>
					</div>
				</section>
				<section data-background="http://i.giphy.com/90F8aUepslB84.gif">
					<h2>... and GIFs!</h2>
				</section>
			</section>

			<section data-transition="slide" data-background="#4d7e65" data-background-transition="zoom">
				<h2>Background Transitions</h2>
				<p>
					Different background transitions are available via the backgroundTransition option. This one's
					called "zoom".
				</p>
				<pre><code class="hljs">Reveal.configure({ backgroundTransition: 'zoom' })</code></pre>
			</section>

			<section data-transition="slide" data-background="#b5533c" data-background-transition="zoom">
				<h2>Background Transitions</h2>
				<p>
					You can override background transitions per-slide.
				</p>
				<pre><code class="hljs" style="word-wrap: break-word;">&lt;section data-background-transition="zoom"&gt;</code></pre>
			</section>

			<section>
				<h2>Pretty Code</h2>
				<pre><code class="hljs" data-trim contenteditable>
function linkify( selector ) {
  if( supports3DTransforms ) {

    var nodes = document.querySelectorAll( selector );

    for( var i = 0, len = nodes.length; i &lt; len; i++ ) {
      var node = nodes[i];

      if( !node.className ) {
        node.className += ' roll';
      }
    }
  }
}
					</code></pre>
				<p>Code syntax highlighting courtesy of <a
						href="http://softwaremaniacs.org/soft/highlight/en/description/">highlight.js</a>.</p>
			</section>

			<section>
				<h2>Marvelous List</h2>
				<ul>
					<li>No order here</li>
					<li>Or here</li>
					<li>Or here</li>
					<li>Or here</li>
				</ul>
			</section>

			<section>
				<h2>Fantastic Ordered List</h2>
				<ol>
					<li>One is smaller than...</li>
					<li>Two is smaller than...</li>
					<li>Three!</li>
				</ol>
			</section>

			<section>
				<h2>Tabular Tables</h2>
				<table>
					<thead>
						<tr>
							<th>Item</th>
							<th>Value</th>
							<th>Quantity</th>
						</tr>
					</thead>
					<tbody>
						<tr>
							<td>Apples</td>
							<td>$1</td>
							<td>7</td>
						</tr>
						<tr>
							<td>Lemonade</td>
							<td>$2</td>
							<td>18</td>
						</tr>
						<tr>
							<td>Bread</td>
							<td>$3</td>
							<td>2</td>
						</tr>
					</tbody>
				</table>
			</section>

			<section>
				<h2>Clever Quotes</h2>
				<p>
					These guys come in two forms, inline: <q
						cite="http://searchservervirtualization.techtarget.com/definition/Our-Favorite-Technology-Quotations">The
						nice thing about standards is that there are so many to choose from</q> and block:
				</p>
				<blockquote
					cite="http://searchservervirtualization.techtarget.com/definition/Our-Favorite-Technology-Quotations">
					&ldquo;For years there has been a theory that millions of monkeys typing at random on millions of
					typewriters would
					reproduce the entire works of Shakespeare. The Internet has proven this theory to be untrue.&rdquo;
				</blockquote>
			</section>

			<section>
				<h2>Intergalactic Interconnections</h2>
				<p>
					You can link between slides internally,
					<a href="#/2/3">like this</a>.
				</p>
			</section>

			<section>
				<h2>Speaker View</h2>
				<p>There's a <a href="https://github.com/hakimel/reveal.js#speaker-notes">speaker view</a>. It includes
					a timer, preview of the upcoming slide as well as your speaker notes.</p>
				<p>Press the <em>S</em> key to try it out.</p>

				<aside class="notes">
					Oh hey, these are some notes. They'll be hidden in your presentation, but you can see them if you
					open the speaker notes window (hit 's' on your keyboard).
				</aside>
			</section>

			<section>
				<h2>Export to PDF</h2>
				<p>Presentations can be <a href="https://github.com/hakimel/reveal.js#pdf-export">exported to PDF</a>,
					here's an example:</p>
				<iframe data-src="https://www.slideshare.net/slideshow/embed_code/42840540" width="445" height="355"
					frameborder="0" marginwidth="0" marginheight="0" scrolling="no"
					style="border:3px solid #666; margin-bottom:5px; max-width: 100%;" allowfullscreen> </iframe>
			</section>

			<section>
				<h2>Global State</h2>
				<p>
					Set <code>data-state="something"</code> on a slide and <code>"something"</code>
					will be added as a class to the document element when the slide is open. This lets you
					apply broader style changes, like switching the page background.
				</p>
			</section>

			<section data-state="customevent">
				<h2>State Events</h2>
				<p>
					Additionally custom events can be triggered on a per slide basis by binding to the
					<code>data-state</code> name.
				</p>
				<pre><code class="javascript" data-trim contenteditable style="font-size: 18px;">
Reveal.addEventListener( 'customevent', function() {
	console.log( '"customevent" has fired' );
} );
					</code></pre>
			</section>

			<section>
				<h2>Take a Moment</h2>
				<p>
					Press B or . on your keyboard to pause the presentation. This is helpful when you're on stage and
					want to take distracting slides off the screen.
				</p>
			</section>

			<section>
				<h2>Much more</h2>
				<ul>
					<li>Right-to-left support</li>
					<li><a href="https://github.com/hakimel/reveal.js#api">Extensive JavaScript API</a></li>
					<li><a href="https://github.com/hakimel/reveal.js#auto-sliding">Auto-progression</a></li>
					<li><a href="https://github.com/hakimel/reveal.js#parallax-background">Parallax backgrounds</a></li>
					<li><a href="https://github.com/hakimel/reveal.js#keyboard-bindings">Custom keyboard bindings</a>
					</li>
				</ul>
			</section>

			<section style="text-align: left;">
				<h1>THE END</h1>
				<p>
					- <a href="https://slides.com">Try the online editor</a> <br>
					- <a href="https://github.com/hakimel/reveal.js">Source code &amp; documentation</a>
				</p>
			</section>

		</div>

	</div>

	<script src="lib/js/head.min.js"></script>
	<script src="js/reveal.js"></script>

	<script>
		// More info https://github.com/hakimel/reveal.js#configuration
		Reveal.initialize({
			controls: true,
			progress: true,
			history: true,
			center: true,

			transition: 'slide', // none/fade/slide/convex/concave/zoom

			// More info https://github.com/hakimel/reveal.js#dependencies
			dependencies: [{
					src: 'lib/js/classList.js',
					condition: function () {
						return !document.body.classList;
					}
				},
				{
					src: 'plugin/markdown/marked.js',
					condition: function () {
						return !!document.querySelector('[data-markdown]');
					}
				},
				{
					src: 'plugin/markdown/markdown.js',
					condition: function () {
						return !!document.querySelector('[data-markdown]');
					}
				},
				{
					src: 'plugin/highlight/highlight.js',
					async: true,
					callback: function () {
						hljs.initHighlightingOnLoad();
					}
				},
				{
					src: 'plugin/search/search.js',
					async: true
				},
				{
					src: 'plugin/zoom-js/zoom.js',
					async: true
				},
				{
					src: 'plugin/notes/notes.js',
					async: true
				}
			]
		});
	</script>
	<script>
		$('.edit').html('');
	</script>
</body>

</html>